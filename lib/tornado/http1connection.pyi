# Stubs for tornado_py3.http1connection (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

import logging
import types
from tornado_py3 import httputil, iostream
from tornado_py3.concurrent import Future
from typing import Any, Awaitable, Callable, Optional, Type, Union

class _QuietException(Exception):
    def __init__(self) -> None: ...

class _ExceptionLoggingContext:
    logger: Any = ...
    def __init__(self, logger: logging.Logger) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, typ: Optional[Type[BaseException]], value: Optional[BaseException], tb: types.TracebackType) -> None: ...

class HTTP1ConnectionParameters:
    no_keep_alive: Any = ...
    chunk_size: Any = ...
    max_header_size: Any = ...
    header_timeout: Any = ...
    max_body_size: Any = ...
    body_timeout: Any = ...
    decompress: Any = ...
    def __init__(self, no_keep_alive: bool=..., chunk_size: Optional[int]=..., max_header_size: Optional[int]=..., header_timeout: Optional[float]=..., max_body_size: Optional[int]=..., body_timeout: Optional[float]=..., decompress: bool=...) -> None: ...

class HTTP1Connection(httputil.HTTPConnection):
    is_client: Any = ...
    stream: Any = ...
    params: Any = ...
    context: Any = ...
    no_keep_alive: Any = ...
    def __init__(self, stream: iostream.IOStream, is_client: bool, params: Optional[HTTP1ConnectionParameters]=..., context: Optional[object]=...) -> None: ...
    def read_response(self, delegate: httputil.HTTPMessageDelegate) -> Awaitable[bool]: ...
    def set_close_callback(self, callback: Optional[Callable[[], None]]) -> None: ...
    def close(self) -> None: ...
    def detach(self) -> iostream.IOStream: ...
    def set_body_timeout(self, timeout: float) -> None: ...
    def set_max_body_size(self, max_body_size: int) -> None: ...
    def write_headers(self, start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine], headers: httputil.HTTPHeaders, chunk: Optional[bytes]=...) -> Future[None]: ...
    def write(self, chunk: bytes) -> Future[None]: ...
    def finish(self) -> None: ...

class _GzipMessageDelegate(httputil.HTTPMessageDelegate):
    def __init__(self, delegate: httputil.HTTPMessageDelegate, chunk_size: int) -> None: ...
    def headers_received(self, start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine], headers: httputil.HTTPHeaders) -> Optional[Awaitable[None]]: ...
    async def data_received(self, chunk: bytes) -> None: ...
    def finish(self) -> None: ...
    def on_connection_close(self) -> None: ...

class HTTP1ServerConnection:
    stream: Any = ...
    params: Any = ...
    context: Any = ...
    def __init__(self, stream: iostream.IOStream, params: Optional[HTTP1ConnectionParameters]=..., context: Optional[object]=...) -> None: ...
    async def close(self) -> None: ...
    def start_serving(self, delegate: httputil.HTTPServerConnectionDelegate) -> None: ...
