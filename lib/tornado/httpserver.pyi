# Stubs for tornado_py3.httpserver (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

import ssl
from tornado_py3 import httputil, iostream
from tornado_py3.tcpserver import TCPServer
from tornado_py3.util import Configurable
from typing import Any, Awaitable, Callable, Dict, List, Optional, Tuple, Type, Union

class HTTPServer(TCPServer, Configurable, httputil.HTTPServerConnectionDelegate):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    request_callback: Any = ...
    xheaders: Any = ...
    protocol: Any = ...
    conn_params: Any = ...
    trusted_downstream: Any = ...
    def initialize(self, request_callback: Union[httputil.HTTPServerConnectionDelegate, Callable[[httputil.HTTPServerRequest], None]], no_keep_alive: bool=..., xheaders: bool=..., ssl_options: Optional[Union[Dict[str, Any], ssl.SSLContext]]=..., protocol: Optional[str]=..., decompress_request: bool=..., chunk_size: Optional[int]=..., max_header_size: Optional[int]=..., idle_connection_timeout: Optional[float]=..., body_timeout: Optional[float]=..., max_body_size: Optional[int]=..., max_buffer_size: Optional[int]=..., trusted_downstream: Optional[List[str]]=...) -> None: ...
    @classmethod
    def configurable_base(cls: Any) -> Type[Configurable]: ...
    @classmethod
    def configurable_default(cls: Any) -> Type[Configurable]: ...
    async def close_all_connections(self) -> None: ...
    def handle_stream(self, stream: iostream.IOStream, address: Tuple) -> None: ...
    def start_request(self, server_conn: object, request_conn: httputil.HTTPConnection) -> httputil.HTTPMessageDelegate: ...
    def on_close(self, server_conn: object) -> None: ...

class _CallableAdapter(httputil.HTTPMessageDelegate):
    connection: Any = ...
    request_callback: Any = ...
    request: Any = ...
    delegate: Any = ...
    def __init__(self, request_callback: Callable[[httputil.HTTPServerRequest], None], request_conn: httputil.HTTPConnection) -> None: ...
    def headers_received(self, start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine], headers: httputil.HTTPHeaders) -> Optional[Awaitable[None]]: ...
    def data_received(self, chunk: bytes) -> Optional[Awaitable[None]]: ...
    def finish(self) -> None: ...
    def on_connection_close(self) -> None: ...

class _HTTPRequestContext:
    address: Any = ...
    address_family: Any = ...
    remote_ip: Any = ...
    protocol: Any = ...
    trusted_downstream: Any = ...
    def __init__(self, stream: iostream.IOStream, address: Tuple, protocol: Optional[str], trusted_downstream: Optional[List[str]]=...) -> None: ...

class _ProxyAdapter(httputil.HTTPMessageDelegate):
    connection: Any = ...
    delegate: Any = ...
    def __init__(self, delegate: httputil.HTTPMessageDelegate, request_conn: httputil.HTTPConnection) -> None: ...
    def headers_received(self, start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine], headers: httputil.HTTPHeaders) -> Optional[Awaitable[None]]: ...
    def data_received(self, chunk: bytes) -> Optional[Awaitable[None]]: ...
    def finish(self) -> None: ...
    def on_connection_close(self) -> None: ...
HTTPRequest = httputil.HTTPServerRequest
