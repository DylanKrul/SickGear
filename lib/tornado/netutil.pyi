# Stubs for tornado_py3.netutil (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

import concurrent.futures
import socket
import ssl
from tornado_py3.util import Configurable
from typing import Any, Awaitable, Callable, Dict, List, Optional, Tuple, Type, Union

def bind_sockets(port: int, address: Optional[str]=..., family: socket.AddressFamily=..., backlog: int=..., flags: Optional[int]=..., reuse_port: bool=...) -> List[socket.socket]: ...
def bind_unix_socket(file: str, mode: int=..., backlog: int=...) -> socket.socket: ...
def add_accept_handler(sock: socket.socket, callback: Callable[[socket.socket, Any], None]) -> Callable[[], None]: ...
def is_valid_ip(ip: str) -> bool: ...

class Resolver(Configurable):
    @classmethod
    def configurable_base(cls: Any) -> Type[Resolver]: ...
    @classmethod
    def configurable_default(cls: Any) -> Type[Resolver]: ...
    def resolve(self, host: str, port: int, family: socket.AddressFamily=...) -> Awaitable[List[Tuple[int, Any]]]: ...
    def close(self) -> None: ...

class DefaultExecutorResolver(Resolver):
    async def resolve(self, host: str, port: int, family: socket.AddressFamily=...) -> List[Tuple[int, Any]]: ...

class ExecutorResolver(Resolver):
    io_loop: Any = ...
    executor: Any = ...
    close_executor: Any = ...
    def initialize(self, executor: Optional[concurrent.futures.Executor]=..., close_executor: bool=...) -> None: ...
    def close(self) -> None: ...
    def resolve(self, host: str, port: int, family: socket.AddressFamily=...) -> List[Tuple[int, Any]]: ...

class BlockingResolver(ExecutorResolver):
    def initialize(self) -> None: ...

class ThreadedResolver(ExecutorResolver):
    def initialize(self, num_threads: int=...) -> None: ...

class OverrideResolver(Resolver):
    resolver: Any = ...
    mapping: Any = ...
    def initialize(self, resolver: Resolver, mapping: dict) -> None: ...
    def close(self) -> None: ...
    def resolve(self, host: str, port: int, family: socket.AddressFamily=...) -> Awaitable[List[Tuple[int, Any]]]: ...

def ssl_options_to_context(ssl_options: Union[Dict[str, Any], ssl.SSLContext]) -> ssl.SSLContext: ...
def ssl_wrap_socket(socket: socket.socket, ssl_options: Union[Dict[str, Any], ssl.SSLContext], server_hostname: Optional[str]=..., **kwargs: Any) -> ssl.SSLSocket: ...
